 /* RMQ снизу */
     class RMQ {
         int[] val; // массив значений
         int[] ind; // массив индексов
         int n; // размер "виртуального" массива
         
                /* Конструктор для пустого RMQ */
                RMQ(int n) {
                    this.n = n;
                    val = new int [2 * n + 1];
                    ind = new int [2 * n + 1];
                    Arrays.fill(val, INF); // заполняем массив значений
                    Arrays.fill(ind, 0);
                    for (int i = 0; i < n; i++)
                        ind[n + i] = i; // не забываем заполнить массив индексов
                }
                
                /* Конструктор RMQ по массиву */
                RMQ(int[] a) {
                    this.n = a.length;
                    val = new int [2 * n + 1];
                    ind = new int [2 * n + 1];
                    for (int i = 0; i < n; i++) {
                        val[n + i] = a[i];
                        ind[n + i] = i;
                    }
                    for (int v = n - 1; v > 0; v--) { // бежим по всем вершинам
                        int l = v << 1; // номер левого сына
                        int r = l + 1; // номер правого сына
                       if (val[l] < val[r]) { // если левом сыне значение меньше
                     val[v] = val[l]; // берем его значение
                     ind[v] = ind[l]; // и индекс
                 } else { // иначе нас интерисует правый сын
                     val[v] = val[r]; // берем его значение
                     ind[v] = ind[r]; // и индекс
                 }
             }
         }
         
         /* Поместить в элемент с индексом i значение value */
         void set(int i, int value) {
             i += n; // получаем номер вершины в RMQ
             val[i] = value; // помещаем значение
             for (int v = i >> 1; v > 0; v >>= 1) { // бежим по предкам
                int l = v << 1; // номер левого сына
                int r = l + 1; // номер правого сына
                if (val[l] < val[r]) { // если левом сыне значение меньше
                     val[v] = val[l]; // берем его значение
                     ind[v] = ind[l]; // и индекс
                 } else { // иначе нас интерисует правый сын
                     val[v] = val[r]; // берем его значение
                     ind[v] = ind[r]; // и индекс
                 }
             }
         }
         
         /* Получить значение элемента с индексом i */
         int get(int i) {
             return val[i + n];
         }
         
         /* Получить значение минимального элемента на отрезке [l, r] */
         int minVal(int l, int r) {
             l += n; // получаем номер левой вершины
             r += n; // получаем номер правой вершины
             int ret = INF; // возвращаемое значение (минимум для запроса)
             while (l <= r) { // пока вершины не пересеклись
                 if ((l & 1) == 1) // если левое поддерево "отпадет"
                     ret = Math.min(ret, val[l]); // то учтем его значение
                 if ((r & 1) == 0) // если правое поддерево "отпадет"
                     ret = Math.min(ret, val[r]); // то учтем его значение
                 l = (l + 1) >> 1; // сделаем переход для левой вершины
                 r = (r - 1) >> 1; // сделаем переход для правой вершины
             }
             return ret;
         }
         
         /* Получить номер минимального элемента на отрезке [l, r] (если нет, то -1) */
         int minInd(int l, int r) {
             l += n; // получаем номер левой вершины
             r += n; // получаем номер правой вершины
             int min = INF; // значение текущего минимального элемента
             int ret = -1; // возвращаемое значение (номер минимального элемента)
             while (l <= r) { // пока вершины не пересеклись
                 if ((l & 1) == 1) // если левое поддерево "отпадет"
                     if (min > val[l]) { // и значение в нем меньше текущего
                         min = val[l]; // обновим текущее значение
                         ret = ind[l]; // и индекс
                     }
                 if ((r & 1) == 0) // если правое поддерево "отпадет"
                     if (min > val[r]) { // и значение в нем меньше текущего
                        min = val[r]; // обновим текущее значение
                         ret = ind[r]; // и индекс
                     }
                 l = (l + 1) >> 1; // сделаем переход для левой вершины
                 r = (r - 1) >> 1; // сделаем переход для правой вершины
             }
             return ret;
         }
     }
